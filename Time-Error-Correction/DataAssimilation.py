# -*- coding: utf-8 -*-
"""Contains methods for data assimilation."""


import numpy as analytics
from scipy import stats     
import math                 
import EnsembleOperations  






def get_posterior(ensembleValues, observation, observationError):
    """
    Assuming normality, uses Bayes' Rule to find the posterior distribution from an ensemble/prior and an observation distribution.
    
    Takes ensembleValues (observed only, as returned by get_observed_values_from_ensemble), observation as array of variable values in same order as ensemble, and assumed error in observations.
    """
    #Convenience
    numberOfVariables = len(ensembleValues)    
    
    #Priors    
    ensembleMeans = [analytics.mean(valueList) for valueList in ensembleValues]
    ensembleSpreads = [analytics.std(valueList) for valueList in ensembleValues]
    
    #Compute Posterior 
    posteriorMeans = []
    posteriorSpreads = []
    for variable in range(numberOfVariables):
        #If there is no spread in the ensemble, it is completely certain and we don't need to adjust it.
        if ensembleSpreads[variable] == 0:
            posteriorSpreads.append(0)
            posteriorMeans.append(ensembleMeans[variable])
        #If there is no spread in the observation likelihood, we are completely certain it is accurate and we can set the ensemble to its value.
        elif observationError[variable] == 0:
            posteriorSpreads.append(0)
            posteriorMeans.append(observation[variable])
            
        #If there is spread in both ensemble and observation:
        #                 ______________________
        #                /__________1___________
        #std-post =     /____1____  + ___1___    
        #             \/(std-pri)^2  (std-lik)^2
        # and
        #
        #mean-post = (std-post)^2 *   ___mean-pri___  +  ____obs____
        #                              (std-pri)^2       (std-lik)^2
        #
        #where pri is prior, obs is observed (lik is observation likelihood), and post is posterior
        
        else:
            
            posteriorSpreads.append(math.sqrt(1/(ensembleSpreads[variable]**-2 + observationError[variable]**-2)))
            posteriorMeans.append((posteriorSpreads[-1]**2)*(ensembleMeans[variable]*ensembleSpreads[variable]**-2 + observation[variable]*observationError[variable]**-2))
            
    return posteriorSpreads, posteriorMeans
    
    
    
    
    

def get_state_incs(ensembleValues, observationIncrements):
    """
    Regresses observation increments onto other variables for each observed variable.
    
    Takes ensembleValues(with observedStatus) and observation increments. Length of observationIncrements should equal that of ensembleValues.
    """
    newEnsembleValues = EnsembleOperations.copy_ensemble_values(ensembleValues)
    stateIncrements = [[[] for j in range(len(observationIncrements))] for i in range(len(newEnsembleValues))]
    observedIndex = 0
    for observed in range(len(newEnsembleValues)):
        if newEnsembleValues[observed][0]:
            for unobserved in range(len(newEnsembleValues)):
                slope, intercept, r_value, p_value, std_err = stats.linregress(newEnsembleValues[observed][1],newEnsembleValues[unobserved][1])
#                if observed == unobserved:
#                    slope = 1
#                else:
#                    slope = 0
                for point in range(len(newEnsembleValues[0][1])):  #Apply increments
                    stateIncrement = observationIncrements[observed][point]*slope
                    newEnsembleValues[unobserved][1][point] += stateIncrement
                    stateIncrements[observedIndex][unobserved].append(stateIncrement)
            observedIndex += 1
                    
    return stateIncrements
    
    
    
    
    
def apply_state_increments(ensembleValues, stateIncrements):
    """
    Applies state increments generated by get_state_increments.
    """
    newEnsembleValues = EnsembleOperations.copy_ensemble_values(ensembleValues)
    for i in range(len(stateIncrements)):
        for var in range(len(stateIncrements[i])):
            newEnsembleValues[var][1] = [newEnsembleValues[var][1][point] + stateIncrements[i][var][point] for point in range(len(ensembleValues[var][1]))]
    return newEnsembleValues
    




def obs_incs_EAKF(ensembleValues, posteriorMeans, posteriorSpreads):
    """
    Calculates observation increments based on prior and posterior distributions.
    
    Takes ensemble values like get_posterior and information about posterior analogous to output of get_posterior.
    Returns observation increments.
    """                    
    #Priors    
    ensembleMeans = [analytics.mean(valueList) for valueList in ensembleValues]
    ensembleSpreads = [analytics.std(valueList) for valueList in ensembleValues]
    observedIncrements = [[] for valueList in ensembleValues]
    for var in range(len(ensembleValues)):
        meanDifference = posteriorMeans[var] - ensembleMeans[var]
        spreadRatio = posteriorSpreads[var] / ensembleSpreads[var]
        for point in ensembleValues[var]:
            newValue = point + meanDifference
            distanceFromPosteriorMean = newValue - posteriorMeans[var]
            distanceFromPosteriorMean *= spreadRatio
            observedIncrements[var].append(posteriorMeans[var] + distanceFromPosteriorMean - point)
    return observedIncrements

        
        
        
        
        
def EAKF(ensemble, observation, observationError, observedStatus):
    """
    Performs an EAKF assimilation with linear regression. 
    
    Takes ensemble in standard format, observation, assumed observation error, observedStatus as array with length = number of variables. Returns ensemble.
    """
    ensembleValues = EnsembleOperations.get_values_from_ensemble(ensemble, observedStatus) #Yes
    observedValues = EnsembleOperations.get_observed_values_from_ensemble(ensembleValues) #Yes
    posteriorSpreads, posteriorMeans = get_posterior(observedValues, observation, observationError) 
    observedIncrements = obs_incs_EAKF(observedValues, posteriorMeans, posteriorSpreads)
    newEnsembleValues = EnsembleOperations.copy_ensemble_values(ensembleValues)
    get_state_incs(newEnsembleValues, observedIncrements)
    newEnsembleValues = apply_state_increments(ensembleValues, get_state_incs(ensembleValues, observedIncrements))
    newEnsemble = EnsembleOperations.get_ensemble_from_values(newEnsembleValues)
    return newEnsemble
                
            
            
    
    
